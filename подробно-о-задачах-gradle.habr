/* 
 * Исходный текст поста
 * http://habrahabr.ru/post/167227/
 *
 */

----------------------------------------
- Подробно о задачах Gradle
----------------------------------------

<img src="http://habrastorage.org/getpro/habr/post_images/28a/ee2/2e3/28aee22e3febf03bdc9a5309ffb33c09.png"/>

Перевод второй главы книги <a href="http://shop.oreilly.com/product/0636920019909.do">Building and Testing with Gradle</a>

Задача является основным компонентом процесса сборки в билд-файле Gradle. Задачи представляют собой именованные наборы инструкций билда, которые Gradle запускает выполняя сборку приложения. При сравнении с другими билд-системами, задачи могут показаться знакомой абстракцией, однако Gradle предоставляет более развитую модель, в отличие от той, которая вам уже может быть знакома. По сравнению с традиционными возможностями объявления операций билда, связанных зависимостями, задачи Gradle являются полнофункциональными объектами, которыми вы при желании можете управлять программно.

Рассмотрим какими способами можно определить задачу, два ключевых подхода к определеню задач и программный интерфейс, который мы можем использовать для гибкой настройки.<habracut />

<h3>Объявление задач</h3>
Существует простой способ создания задачи. Всё что нужно - указать имя задачи:

<h6>Пример 1. Объявление задачи по одному только имени</h6>
<source lang="dos">
task hello
</source>
Выполнив команду <code>gradle hello</code>, вы получите результат:

<h6>Пример 2. Отчёт Gradle о новой задаче</h6>
<source lang="python">
------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
----------
dependencies - Displays all dependencies declared in root project '__project'.
dependencyInsight - Displays the insight into a specific dependency in root project '__project'.
help - Displays a help message
projects - Displays the sub-projects of root project '__project'.
properties - Displays the properties of root project '__project'.
tasks - Displays the tasks runnable from root project '__project'.

Other tasks
-----------
hello
</source>

<anchor>TaskAction</anchor><h3>Операция задачи (Task Action)</h3>
Выполнение нашей задачи по команде <code>gradle hello</code> всё же не произведёт никакого результата, поскольку мы не присвоили ей ни одной операции. Операцию можно присвоить используя оператор сдвиг влево:

<h6>Пример 3. Добавление задаче простейшей операции</h6>
<source lang="python">
task hello << {
    println 'hello, world'
}
</source>
<i>Операторы, такие как << ("сдвиг влево" из Java), могут быть перегружены в Groovy для изменения поведения в зависимости от объектов с которыми они работают. В данном случае << перегружен в Gradle для добавления блока кода в список операций которые выполняет задача. Сдвиг влево является эквивалентом метода <a href="#DoLast"><code>doLast()</code></a>, который мы рассмотрим ниже.</i>

Теперь у нас есть гибкая возможность добавления кода операции аддитивным способом, ссылаясь на объект задачи, который мы создали:

<h6>Пример 4. Последовательное добавление операций задачи по одной</h6>
<source lang="python">
task hello

hello << {
    print 'hello, '
}

hello << {
    println 'world'
}
</source>
Теперь мы снова получили знакомый нам результат выполнения билда:

<h6>Пример 5. Результат выполнения билда с операциями добавленными по одной</h6>
<source lang="dos">
d:\project>gradle hello
:hello
hello, world

BUILD SUCCESSFUL

Total time: 1.916 secs
</source>
Данное поведение тривиально, однако оно раскрывает важный принцип: задачи не являются статическими неизменяемыми объявлениями операций билда; задачи - полнофункциональные объекты программной среды Gradle. Кроме добавления в них операций аддитивным способом в произвольных местах билд-файла, у нас есть ещё и другие возможности. Посмотрим какие.

<anchor>TaskConfiguration</anchor><h3>Конфигурация задачи</h3>
Новые пользователи Gradle обычно путаются в синтаксисе конфигурации когда пытаются определить операции задач. Продолжая предыдущий пример мы можем расширить его, добавив блок конфигурации:

<h6>Пример 6. Комбинирование конфигурации и операции задачи</h6>
<source lang="python">
task initializeDatabase

initializeDatabase << {
    println 'connect to database'
}

initializeDatabase << {
    println 'update database schema'
}

initializeDatabase {
    println 'configuring database connection'
}
</source>
Запустив такой билд-файл, мы получим результат, который покажется нам нелогичным:

<h6>Пример 7. Результат выполнения билд-файла созданного выше</h6>
<source lang="dos">
d:\project>gradle initializeDatabase
configuring database connection
:initializeDatabase
connect to database
update database schema

BUILD SUCCESSFUL

Total time: 3.088 secs
</source>
<i>Для обозначения блока кода между парой фигурных скобок, в Groovy используется термин "замкнутое выражение" или "замыкание" (closure). Функции-замыкания подобны объектам, которые можно передавать методу как параметр или присваивать переменной, с возможностью последующего выполнения. Они будут повсеместно встречаться вам в Gradle, поскольку идеально подходят в роли блоков где можно определить конфигурационный код и операции билда.</i>

Последнее замкнутое выражение выглядит как очередной фрагмент операции билда, и мы ожидаем что вывод его сообщения будет последним, но не первым. Оказывается замыкание, добавленное к имени задачи <i>без</i> оператора сдвиг влево вообще не добавляет оператор. Вместо этого добавился блок <i>конфигурации</i>. Конфигурационный блок задачи выполняется во время <i>конфигурационной</i> фазы жизненного цикла Gradle, которая предшествует фазе <i>выполнения</i>, во время которой выполняются операции задачи.

<i>Каждый раз когда Gradle запускает билд, процесс проходит через три фазы жизненного цикла: инициализация, конфигурация и выполнение. Выполнение - фаза во время которой задачи билда выполняются в порядке, указанном в настройках их зависимостей. Конфигурация - фаза в которой объекты задачи собираются во внутреннюю объектную модель, обычно называемую <u>направленным ациклическим графом</u>. Инициализация - фаза в которой Gradle принимает решение какие объекты будут принимать участие в билде. Последняя фаза важна в многопроектных билдах.</i>

Конфигурационные замыкания аддитивны точно так же, как и замыкания операций. Поэтому мы можем написать код билд-файла для предыдущего примера способом приведенным ниже, при этом результат выполнения будет тот же, что и раньше:

<h6>Пример 8. Добавление конфигурационных блоков</h6>
<source lang="python">
task initializeDatabase

initializeDatabase << {
    println 'connect to database'
}

initializeDatabase << {
    println 'update database schema'
}

initializeDatabase {
    print 'configuring '
}

initializeDatabase {
    println 'database connection'
}
</source>

Конфигурационный блок - подходящее место для присвоения значений переменных и структур данных, которые будут нужны операции задачи когда (и если) она потом запустится в билде. Структура конфигурации даёт вам возможность превратить задачи вашего билда в сущности развитой объектной модели, заполненные информацией о билде. В этом и состоит отличие задач Gradle от простого набора операций билда, которые выполняются в определённой последовательности. Без такого отличия между конфигурацией и операцией, пришлось бы усложнять настройки зависимостей, что привело бы к потере надёжности и к снижению выразительности средств для связывания основных структур данных билда.

<i>При запуске Gradle-файла конфигурационный код билда выполняется полностью, независимо от того, будет ли какая-либо из задач запускаться в фазе выполнения.</i>

<anchor>TasksAreObjects</anchor><h3>Задачи являются объектами</h3>
В этом месте у вас уже могла появиться догадка о том, что Gradle создаёт внутреннюю объектную модель билда перед тем как его выполнить. Именно так всё и происходит. Каждая задача, которую вы объявляете, в действительности становится объектом-задачей в пределах всего билд-проекта. У объекта-задачи, как и у любого другого объекта, есть свойства и методы. И ещё мы можем управлять типом каждого объекта-задачи, обращаясь к функциональности определённой в нём. Несколько примеров помогут нам разобраться.

По умолчанию каждой новой задаче присваивается тип <code>DefaultTask</code>. Подобно тому, как каждый класс наследуется от <code>java.lang.Object</code> в Java, в Gradle каждая задача наследуется от этого типа - даже те задачи, которые расширяют возможности <code>DefaultTask</code> путём создания нового типа. На самом деле <code>DefaultTask</code>-задачи не делают ничего умного вроде компиляции кода или копирования файлов. Однако они содержат функционал, который требуется для взаимодействия с программной моделью проекта Gradle. Рассмотрим методы и свойства, которые имеет каждая задача в Gradle.

<h4>Методы DefaultTask</h4>
<h5>dependsOn(task)</h5>
Для вызывающей задачи добавляет задачу-зависимость. Задача-зависимость всегда запускается перед задачей, которая зависит от неё. Метод можно вызывать несколькими способами. Пример кода ниже показывает, как мы можем определить зависимость задачи <code>loadTestData</code> от <code>createSchema</code>:

<h6>Пример 9. Различные способы вызова метода <code>dependsOn</code></h6>
<source lang="python">
task createSchema

// Объявляем зависимость 'loadTestData' от 'createSchema'
// Остальные зависимости, определённые ранее, остаются неизменными
task loadTestData {
    dependsOn createSchema
}

// Альтернативный способ указания той же зависимости
task loadTestData {
    dependsOn << createSchema
}

// Делаем то же самое, используя одиночные кавычки (которые обычно не нужны)
task loadTestData {
    dependsOn 'createSchema'
}

// Явный вызов метода объекта-задачи
task loadTestData
loadTestData.dependsOn createSchema

// Краткая нотация для определения зависимостей
task loadTestData(dependsOn: createSchema)
</source>
Задача может зависеть от нескольких задач. Если задача <code>loadTestData</code> зависит от задач <code>createSchema</code> и <code>compileTestClasses</code>, мы пишем код следующим образом:

<h6>Пример 10. Различные способы вызова метода dependsOn для множественных зависимостей</h6>
<source lang="python">
task compileTestClasses
task createSchema

// Объявление зависимостей по одной
task loadTestData {
    dependsOn << compileTestClasses
    dependsOn << createSchema
}

// Передаём зависимости как список переменной длины
task loadTestData {
    dependsOn compileTestClasses, createSchema
}

// Явно вызываем метод объекта-задачи
task loadTestData
loadTestData.dependsOn compileTestClasses, createSchema

// Краткая нотация для определения зависимостей
// Обратите внимание на синтаксис списков Groovy
task loadTestData(dependsOn: [ compileTestClasses, createSchema ])
</source>
<anchor>DoFirst</anchor><h5>doFirst(closure)</h5>
Добавляет блок исполняемого кода в начало операции задачи. Во время фазы выполнения запускается блок операции каждой участвующей в билде задачи. Метод <code>doFirst</code> позволяет вам добавлять части логики в начало существующей операции, даже если эта операция уже определена в билд-файле или внешнем модуле (plug-in), к которому у вас нет доступа. Вызов <code>doFirst</code> несколько раз добавляет новые блоки с кодом операции в начало последовательности выполнения задачи.

Метод <code>doFirst</code> можно вызывать напрямую для объекта-задачи, передавая ему замыкание, которое содержит код, который будет выполнен перед текущей операцией задачи.

<i>Как мы уже говорили, замыкание это блок Groovy кода, заключённый между парой фигурных скобок. Замыкание можно передавать методу как любой другой объект. Возможность пердавать методам замкнутые выражения является стилевой особенностью Groovy.</i>

<h6>Пример 11. Вызов метода doFirst объекта-задачи</h6>
<source lang="python">
task setupDatabaseTests << {
    // Здесь определена текущая операция задачи
    println 'load test data'
}

setupDatabaseTests.doFirst {
    println 'create schema'
}
</source>
<h6>Пример 12. Результат выполнения прошлого билд-файла</h6>
<source lang="dos">
d:\project>gradle setupDatabaseTests
:setupDatabaseTests
create schema
load test data

BUILD SUCCESSFUL

Total time: 1.935 secs
</source>
<code>doFirst</code> можно также вызывать в конфигурационном блоке задачи. Как мы уже говорили, конфигурационный блок это часть исполняемого кода, которая запускается во время конфигурационной фазы билда перед тем как будут выполнены операции задачи. Когда мы рассматривали выше конфигурацию задач, у вас мог возникнуть вопрос: где вообще можно использовать конфигурационные блоки? Следующий пример покажет вам, как можно вызывать методы задачи внутри конфигурационного блока, что в перспективе делает очень выразительным синтаксис формата изменения поведения задачи:

<h6>Пример 13. Вызов метода <code>doFirst</code> внутри конфигурационного блока задачи</h6>
<source lang="python">
task setupDatabaseTests << {
    println 'load test data'
}

setupDatabaseTests {
    doFirst {
        println 'create schema'
    }
}
</source>
Повторные вызовы <code>doFirst</code> аддитивны. Код операции каждого предыдущего вызова сохраняется, и новое замыкание добавляется в начало списка, готовое выполниться в соответствующем порядке. Например, если нам нужно настроить базу данных для интеграционного тестирования (разбив этапы настройки по частям), можно использовать следующий код:

<h6>Пример 14. Повторные вызовы <code>doFirst</code> обладают свойством аддитивности</h6>
<source lang="python">
task setupDatabaseTests << {
    println 'load test data'
}

setupDatabaseTests.doFirst {
    println 'create database schema'
}

setupDatabaseTests.doFirst {
    println 'drop database schema'
}
</source>
<h6>Пример 15. Результат выполнения предыдущего примера</h6>
<source lang="dos">
d:\project>gradle setupDatabaseTests
:setupDatabaseTests
drop database schema
create database schema
load test data

BUILD SUCCESSFUL

Total time: 3.126 secs
</source>
В предыдущем примере разделение инициализации на три отдельных замыкания с вызовом <code>doFirst()</code>, было, конечно же, несколько искуственным шагом. Однако, бывают случаи, когда исходный код задачи недоступен. Например, задача определена в другом билд-файле, модифицировать который невозможно или непрактично. Рассматриваемый способ программной модификации недоступной логики открывает нам широкие возможности.

До сих пор в наших примерах использоватлся очень простой синтаксис, который раскрывает принципы работы Gradle за счёт многократных добавлений замыканий. Вероятнее всего, в реальном билде мы организуем задачу следующим образом (всё так же, вместо настоящих тестовых операций мы используем операторы <code>println</code>):

<h6>Пример 16. Повторные вызовы doFirst после рефакторинга</h6>
<source lang="python">
// Исходное определение задачи (может быть недоступно для редактирования)
task setupDatabaseTests << {
    println 'load test data'
}

// Наши изменения задачи (в файле, где мы можем вносить изменения)
setupDatabaseTests {
    doFirst {
        println 'create database schema'
    }
    doFirst {
        println 'drop database schema'
    }
}
</source>
Обратите внимание на то что мы собрали вместе несколько вызовов <code>doFirst</code> внутри одного конфигурационного блока после того как начальная операция уже была добавлена в задачу <code>setupDatabaseTests</code>.

<anchor>DoLast</anchor><h5>doLast(closure)</h5>
Метод <code>doLast</code> очень похож на метод <a href="#DoFirst"><code>doFirst</code></a>, с той лишь разницей, что он добавляет поведение в конец операции, а не в начало. Если вам нужно запустить блок кода после того как некоторая задача закончит выполнение, вы можете поступить следующим образом:

<h6>Пример 17. Использование метода doLast</h6>
<source lang="python">
task setupDatabaseTests << {
    println 'create database schema'
}

setupDatabaseTests.doLast {
    println 'load test data'
}
</source>
<h6>Пример 18. Повторные вызовы doLast аддитивны</h6>
<source lang="python">
task setupDatabaseTests << {
    println 'create database schema'
}

setupDatabaseTests.doLast {
    println 'load test data'
}

setupDatabaseTests.doLast {
    println 'update version table'
}
</source>
<i>Как уже говорилось ранее в параграфе <a href="#TaskAction">Операция задачи</a>, оператор << является ещё одним способом вызова метода <code>doLast()</code>.</i>

<h5>onlyIf(closure)</h5>
Метод <code>onlyIf</code> позволяет вам использовать предикат, который определяет, будет ли задача выполняться. Значением предиката считается значение возвращаемое замыканием. При помощи данного метода вы можете деактивировать выполнение задачи, которая иначе запустится в обычном порядке запуска последовательности зависимостей билда.

<i>В Groovy последнее выражение внутри замыкания определяет его возвращаемое значение, даже если оператор <code>return</code> отсутствует. Метод Groovy, в котором определено только одно выражение является функцией, возвращающей значение этого выражения.</i>

<h6>Пример 19. Билд-файл, в котором используется метод onlyIf</h6>
<source lang="python">
task createSchema << {
    println 'create database schema'
}

task loadTestData(dependsOn: createSchema) << {
    println 'load test data'
}

loadTestData.onlyIf {
    System.properties['load.data'] == 'true'
}
</source>
<h6>Пример 20. Два варианта запуска билд-файла. Обратите внимание на разницу в результатах</h6>
<source lang="dos">
d:\project>gradle loadTestData
:createSchema
create database schema
:loadTestData SKIPPED

BUILD SUCCESSFUL

Total time: 4.361 secs
d:\project>gradle -Dload.data=true loadTestData
:createSchema
create database schema
:loadTestData
load test data

BUILD SUCCESSFUL

Total time: 2.005 secs
</source>
При помощи метода <code>onlyIf</code> вы можете включать и отключать отдельные задачи, используя логику, выражаемую Groovy-кодом, что не ограничиваться одной лишь проверкой простого свойства <code>System</code>, которое мы использовали в примере. У вас есть возможности открывать файлы для чтения, вызывать Веб-сервисы, проверять логины-пароли и делать многое другое, что можно делать в коде.

<h4>Свойства DefaultTask</h4>
<h5>didWork</h5>
Свойство типа <code>boolean</code>, указывающее, завершилась ли задача успешно. Не все задачи устанавливают значение <code>didWork</code> к моменту завершения. Однако некоторые задачи, такие как <code>Compile</code>, <code>Copy</code> и <code>Delete</code>, устанавливают значение данного свойства для передачи информации о том что их операции выполнены либо успешно, либо с ошибками. Вычисление значения, указывающего на то, что задача уже выполнилась специфично для разных задач. Вы можете установить значение <code>didWork</code> в вашей задаче для отражения результатов выполнения созданного вами кода сборки:

<h6>Пример 21. Отправка электронного письма для случая, когда компиляция прошла успешно</h6>
<source lang="python">
apply plugin: 'java'

task emailMe(dependsOn: compileJava) << {
    if (tasks.compileJava.didWork) {
        println 'SEND E-MAIL ANNOUNCING SUCCESS'
    }
}
</source>
<h6>Пример 22. Результаты выполнения билда с испльзованием didWork</h6>
<source lang="dos">
d:\project>gradle emailMe
:compileJava
:emailMe
SEND E-MAIL ANNOUNCING SUCCESS

BUILD SUCCESSFUL

Total time: 4.232 secs
</source>
<h5>enabled</h5>
Свойство типа <code>boolean</code>, указывающее на то, будет ли выполняться задача. Вы можете отключить выполнение задачи, установив свойству <code>enabled</code> значение <code>false</code>. Зависимости задачи выполнятся в том же порядке, как если бы задача не была отключена.

<h6>Пример 23. Отключение задачи</h6>
<source lang="python">
task templates << {
    println 'process email templates'
}

task sendEmails(dependsOn: templates) << {
    println 'send emails'
}

sendEmails.enabled = false
</source>
<h6>Пример 24. Билд с отключенной задачей. Обратите внимание, зависимость всё так же запускается</h6>
<source lang="dos">
d:\project>gradle -b enabled.gradle sendEmails
:templates
process email templates
:sendEmails SKIPPED

BUILD SUCCESSFUL

Total time: 3.271 secs
</source>
<i>Параметр командной строки <b>-b</b> указывает Gradle на отличный от файла по умолчанию билд-файл. По умолчанию Gradle ищет файл с называнием <code>build.gradle</code>, но данный параметр командной строки позволяет нам указать другой файл.</i>

<h5>path</h5>
Свойство строчного типа, содержащее полный путь задачи. По умолчанию путём задачи является имя задачи с символом двоеточие впереди.

<h6>Пример 25. Одноуровневый билд-файл, который отображает путь единственной задачи, определённой в нём</h6>
<source lang="python">
task echoMyPath << {
    println "THIS TASK'S PATH IS ${path}"
}
</source>
<h6>Пример 26. Результаты выполнения предыдущего билд-файла</h6>
<source lang="dos">
d:\project>gradle echoMyPath
:echoMyPath
THIS TASK'S PATH IS :echoMyPath

BUILD SUCCESSFUL

Total time: 3.135 secs
</source>
Двоеточие впереди указывает на то что задача определена на верхнем уровне билд-файла. Расположение задач на верхнем уровне, однако, не является обязательным. Gradle поддерживает зависимые подпроекты, или вложенные билды. Если задача определёна во вложенном билде с названием <code>subProject</code>, путь будет <code>:subProject:echoMyPath</code>.

<anchor>Logger</anchor><h5>logger</h5>
Ссылка на внутренний объект Gradle <code>logger</code>. В Gradle <code>logger</code> реализует интерфейс <code>org.slf4j.Logger</code> с несколькими дополнительными уровнями логирования. Ниже описаны уровни логирования, поддерживаемые объектом <code>logger</code>. Установка уровня логирования в одно из значений ниже включает логирование на всех последующих уровнях кроме <code>WARN</code> и <code>QUIET</code>:

<ul>
	<li><code>DEBUG</code>. Для подробных сообщений логирования, которые нужны разработчику билда, однако не должны выводиться в момент выполнения билда в нормальном режиме. Если выбран данный уровень, Gradle автоматически использует расширенный формат, который в каждом сообщении вставляет метку времени, уровень логирования, и имя задачи, которая производит логирование. Остальные уровни используют более краткий формат сообщений.</li>
	<li><code>INFO</code>. Нужен для менее информативных сообщений билда, играющих второстепенную роль во время выполнения билда.</li>
	<li><code>LIFECYCLE</code>. Малоинформативные сообщения об изменениях в жизенном цикле билда и процессе выполнениия самого инструмента, запустившего сборку проекта. Обычно генерируются самим Gradle. Данный уровень используется по умолчанию когда Gradle запускается без опции командной строки <b>-q</b>. Данный уровень логирования назначается сообщениям, выводимым оператором <code>println</code>.</li>
	<li><code>WARN</code>. Малоинформативные, но важные сообщения, сообщающие о потенциальных проблемах билда. Когда уровень логирования установлен в <code>WARN</code>, сообщения уровня <code>QUIET</code> не выводятся.</li>
	<li><code>QUIET</code>. Сообщения, которые выводятся даже если вывод сообщений был отключен параметром командной строки <b>-q</b>. (Выполнение билда с параметром <b>-q</b> делает <code>QUIET</code> уровнем логирования по умолчанию). Сообщениям, выводимым оператором <code>System.out.println</code> назначается данный уровень логирования. Когда уровень логирования установлен в <code>QUIET</code>, сообщения уровня <code>WARN</code> не выводятся.</li>
	<li><code>ERROR</code>. Редкие, но важные сообщения, кототые выводятся на всех уровнях логирования. Сообщения информируют о завершении билда с ошибками. Если <code>ERROR</code> - текущий уровень логирования, вызовы <code>System.out.println</code> не будут выводиться в консольном окне.</li>
</ul>
<h6>Пример 27. Таск демонстрирует эфект применения всех уровней логирования. Несколько более сложный код Groovy устанавливает уровень логирования для каждой из возможных опций, определённых в списке. Таким образом, каждый раз осуществляется вывод сообщений на каждом из уровней логирования.</h6>
<source lang="ruby">
task logLevel << {

    def levels = ['DEBUG', 'INFO', 'LIFECYCLE', 'QUIET', 'WARN', 'ERROR']

    levels.each { level ->
        logging.level = level
        def logMessage = "SETTING LogLevel=${level}"

        logger.error logMessage
        logger.error '-' * logMessage.size()
        logger.debug 'DEBUG ENABLED'
        logger.info  'INFO ENABLED'
        logger.lifecycle 'LIFECYCLE ENABLED'
        logger.warn  'WARN ENABLED'
        logger.quiet 'QUIET ENABLED'
        logger.error 'ERROR ENABLED'
        println 'THIS IS println OUTPUT'
        logger.error ' '
    }
}
</source>
<h6>Пример 28. Результат выполнения прошлого билд-файла</h6>
<source lang="dos">
d:\project>gradle logLevel
19:35:44.677 [LIFECYCLE] [class org.gradle.TaskExecutionLogger]
19:35:44.699 [ERROR] [org.gradle.api.Task] SETTING LogLevel=DEBU
19:35:44.732 [ERROR] [org.gradle.api.Task] ---------------------
19:35:44.747 [DEBUG] [org.gradle.api.Task] DEBUG ENABLED
19:35:44.760 [INFO] [org.gradle.api.Task] INFO ENABLED
19:35:44.775 [LIFECYCLE] [org.gradle.api.Task] LIFECYCLE ENABLED
19:35:44.788 [WARN] [org.gradle.api.Task] WARN ENABLED
19:35:44.801 [QUIET] [org.gradle.api.Task] QUIET ENABLED
19:35:44.812 [ERROR] [org.gradle.api.Task] ERROR ENABLED
19:35:44.857 [QUIET] [system.out] THIS IS println OUTPUT
19:35:44.868 [ERROR] [org.gradle.api.Task]
SETTING LogLevel=INFO
---------------------
INFO ENABLED
LIFECYCLE ENABLED
WARN ENABLED
QUIET ENABLED
ERROR ENABLED
THIS IS println OUTPUT

SETTING LogLevel=LIFECYCLE
--------------------------
LIFECYCLE ENABLED
WARN ENABLED
QUIET ENABLED
ERROR ENABLED
THIS IS println OUTPUT

SETTING LogLevel=QUIET
----------------------
QUIET ENABLED
ERROR ENABLED
THIS IS println OUTPUT

SETTING LogLevel=WARN
---------------------
WARN ENABLED
QUIET ENABLED
ERROR ENABLED
THIS IS println OUTPUT

SETTING LogLevel=ERROR
----------------------
ERROR ENABLED


BUILD SUCCESSFUL

Total time: 2.184 secs
</source>

<h5>logging</h5>
Свойство <code>logging</code> даёт нам возможность управлять уровнем логирования. Как уже было показано
в примере для <a href="#Logger">свойства <code>logger</code></a>, уровень логирования билда можно получать и изменять, используя свойство <code>logging.level</code>.

<h5>description</h5>
Свойство <code>description</code>, как видно из названия, описывает назначение задачи небольшим количеством метаданных, доступных для понимания человека. Значение <code>description</code> можно установить несколькими способами:

<h6>Пример 29. Одновременно задаём описание задачи и поведение</h6>
<source lang="python">
task helloWorld(description: 'Says hello to the world') << {
    println 'hello, world'
}
</source>
<h6>Пример 30. Два способа объявления поведения задачи и задания описания</h6>
<source lang="python">
task helloWorld << {
    println 'hello, world'
}

helloWorld {
    description 'Says hello to the world'
}

// Ещё один способ
helloWorld.description 'Says hello to the world'
</source>

<h5>temporaryDir</h5>
Свойство <code>temporaryDir</code> возвращает объект <code>File</code>, который ссылается на временную директорию текущего билд-файла. Такая директория создаётся для временного хранения промежуточных результатов работы задачи, или для организации файлов, которые задача будет обрабатывать.

<h4>Динамические свойства</h4>
Как мы уже видели, задачи содержат набор внутренних свойств, играющих важную роль для пользователей Gradle. В добавок к этому, мы можем также присвоить задаче свойства. Объект-задача работает как хеш-таблица, которая может хранить любые имена свойств и значения, которые мы присваиваем свойствам (при условии что наши имена свойств не конфликтуют с именами встроенных свойств).

Рассмотрим пример: задача <code>createArtifact</code> зависит от задачи <code>copyFiles</code>. Цель <code>copyFiles</code> - собирать файлы из нескольких источников и копировать их во временную директорию, которую <code>createArtifact</code> в дальнейшем преобразует в артифакт установки. Список файлов звисит от параметров билда, но для соответствия специфическим требованиям установленного приложения, в артифакте должен храниться манифест, перечисляющий файлы. Здесь очень удобно использовать динамическое свойство:

<h6>Пример 31. Билд-файл, в котором показан пример динамического свойства</h6>
<source lang="python">
task copyFiles {
    // Где угодно находим файлы, копируем их
    // (здесь для наглядности используем фиксированный список)
    fileManifest = [ 'data.csv', 'config.json' ]
}

task createArtifact(dependsOn: copyFiles) << {
    println "FILES IN MANIFEST: ${copyFiles.fileManifest}"
}
</source>
<h6>Пример 32. Результат выполнения билд-файла из примера выше</h6>
<source lang="dos">
d:\project>gradle -q createArtifact
FILES IN MANIFEST: [data.csv, config.json]
</source>
<anchor>TaskTypes</anchor><h3>Типы задач</h3>
Как мы уже говорили выше, в параграфе <a href="#TasksAreObjects">Задачи являются объектами</a>, каждая задача имеет тип. Кроме типа <code>DefaultTask</code>, есть ещё другие типы задач для копирования, архивирования, запуска программ и другие. Объявление типа задачи во многом похоже на наследование от базового класса в объектно-ориентированном языке. Таким образом, выполнив наследование, вы тут же получаете определённые свойства и методы в вашей задаче. Подобный синтаксис значительно укорачивает определение задач, при том что возможности по-прежнему остаются большими.

Рассмотрение полной документации по задачам находится за рамками излагаемого здесь материала, но всё же мы рассмотрим несколько важных типов с примерами использования.

<h4>Copy</h4>
Задача <code>Copy</code> копирует файлы из одного места в другое. В простейшем случае - копирует файлы из одной директории в другую, с некоторыми дополнительными ограничениями по включению или исключению файлов, используя маски имён:
<h6>Пример 33. Простейший пример испльзования задачи <code>Copy</code></h6>
<source lang="python">
task copyFiles(type: Copy) {
    from 'resources'
    into 'target'
    include '**/*.xml', '**/*.txt', '**/*.properties'
}
</source>
<h4>Jar</h4>
Задача <code>Jar</code> создаёт Jar-файл из файлов ресурсов. Задача данного типа c известным названием <code>Jar</code> определена в модуле <code>'java'</code>. Задача упаковывает *.class-файлы и ресурсы в Jar-файл с названием проекта, при этом использует обычный манифест. Результат сохраняется в директорию <code>build/libs</code>. Данная задача в высшей степени гибкая.
<h6>Пример 34. Простейший пример использования задачи <code>Jar</code></h6>
<source lang="python">
apply plugin: 'java'

task customJar(type: Jar) {
    manifest {
        attributes firstKey: 'firstValue', secondKey: 'secondValue'
    }
    archiveName = 'hello.jar'
    destinationDir = file("${buildDir}/jars")
    from sourceSets.main.output
}
</source>
Обратите внимание - имя архива и целевая папка легко конфигурируются. Таким же образом можно менять значения файла манифеста, используя понятный синтаксис словарей Groovy. Содержимое JAR-файла определяется строкой <code>from sourceSets.main.output</code>, которая включает .class-файлы. Метод <code>from</code> идентичен тому, который используется в примере <code>CopyTask</code>, что обнаруживает одну интересную деталь: задача <code>Jar</code> наследуется от задачи <code>Copy</code>. Зная эту особенность, вы можете ещё не заглянув в документацию сделать некоторые выводы о широких возможностях и порядке структуры классов, лежащей в основе задачи <code>Jar</code>.

<code>destinationDir</code> присваивается очень простое выражение. Было бы естественнее, если бы свойству <code>destinationDir</code> присваивалась строка. Но свойство работает с объектами <code>java.io.File</code>. На помощь приходит метод <code>file()</code>, который всегда доступен в коде билд файла Gradle. Он конвертирует строку в объект <code>File</code>.

<i>Помните, вы всегда можете найти документацию <code>docs/dsl/index.html</code>, где описываны стандартные возможности Gradle, такие как задача <code>Jar</code>. Описание всех возможностей задачи <code>Jar</code> лежит за рамками нашей главы.</i>

<h4>JavaExec</h4>
Задача <code>JavaExec</code> запускает Java-класс c методом <code>main()</code>. Запуск консольного Java-приложения может быть сопряжён с неудобставми. Однако данная задача избавляет от неудобств, интегрируя консольные Java-приложения в ваш билд:

<h6>Пример 35. Задача Gradle запускает консольное Java-приложение (пример взят из <a href="https://github.com/gradleware/oreilly-gradle-book-examples/tree/master/tasks-javaexec-task">javaexec-task</a>)</h6>
<source lang="python">
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    compile 'commons-codec:commons-codec:1.6'
    runtime 'commons-codec:commons-codec:1.6'
}

task encode(type: JavaExec, dependsOn: classes) {
    main = 'org.gradle.example.commandline.MetaphoneEncoder'
    args = "The rain in Spain falls mainly in the plain".split().toList()
    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}
</source>
<source lang="java">
package org.gradle.example.commandline;

import org.apache.commons.codec.language.Metaphone;

public class MetaphoneEncoder {
    public static void main(String args[]) {
        Metaphone codec = new Metaphone();
        String phrase = "";
        String encoded = "";
        for (String s : args) {
            phrase += s.toUpperCase() + " ";
            encoded += codec.encode(s) + " ";
        }

        System.out.println("PHRASE =" + phrase);
        System.out.println("ENCODED=" + encoded);
    }
}
</source>
<i>В задаче <code>encode</code> свойству <code>classpath</code> присваивается <code>configurations.runtime</code>. <code>configurations</code> это коллекция зависимостей имеющих нечто общее. В нашем случае <code>runtime</code> содержит те зависимости, которые должны быть доступны для приложения во время выполнения. Такие зависимости отличны от зависимостей, которые необходимы для компиляции (<code>compile</code>), запуска тестов или зависимостей, которые нужны для компиляции и запуска одновременно, но представлены такой средой выполнения, как сервер приложений. Свойство <code>configurations</code> в Gradle это коллекция всех конфигураций определённых в билде, каждая из которых в свою очередь является коллекцией реальных зависимостей.</i>

В билд-файле объявлена внешняя зависимость от библиотеки Apache Commons Codec. Мы компилируем наш Java-файл, затем формируем командную строку запуска приложения, используя путь скомпилированного .class файла и JAR-зависимость. В билд-файле указываем класс, в котором запустится метод <code>main()</code> (<code>org.gradle.example.commandline.MetaphoneEncoder</code>), задаём ему параметры командной строки в форме списка, и указываем необходимые элементы <code>classpath</code>. В данном случае мы можем условно сослаться на основные классы, доступные в <code>sourceSets</code>, и на все зависимости, объявленные в конфигурации <code>runtime</code>. Задача описанная в примере будет работать даже если мы определим множество других зависимостей из разных репозиториев, включая статические зависимости в директории проекта.

<h3>Пользовательские типы задач</h3>
Иногда возможностей встроенных задач Gradle может быть не достаточно для решения вашей задачи. Тогда создание пользовательской задачи будет самым выразительным способом, который можно применить в разработке вашего билда. В Gradle есть несколько способов сделать это. Мы рассмотрим два наиболее распространённых.

<h4>Определение пользовательского типа задачи в билд-файле</h4>
Допустим, в вашем билде нужно выполнить различные запросы к базе данных MySQL. В Gradle это можно сделать несколькими способами, но вы решили, что создание пользовательской задачи будет наиболее выразительным способом для решения такой задачи. Простейший способ создания задачи - объявить её так, как показано в примере ниже:

<anchor>CustomTaskExample</anchor><h6>Пример 36. Пользовательская задача для выполнения запросов в базе данных MySQL (из примера <a href="https://github.com/gradleware/oreilly-gradle-book-examples/blob/master/tasks-custom-task/build.gradle">custom-task</a></h6>
<source lang="javascript">
task createDatabase(type: MySqlTask) {
  sql = 'CREATE DATABASE IF NOT EXISTS example'
}

task createUser(type: MySqlTask, dependsOn: createDatabase) {
  sql = "GRANT ALL PRIVILEGES ON example.* TO exampleuser@localhost IDENTIFIED BY 'passw0rd'"
}

task createTable(type: MySqlTask, dependsOn: createUser) {
  username = 'exampleuser'
  password = 'passw0rd'
  database = 'example'
  sql = 'CREATE TABLE IF NOT EXISTS users (id BIGINT PRIMARY KEY, username VARCHAR(100))'
}

class MySqlTask extends DefaultTask {
  def hostname = 'localhost'
  def port = 3306
  def sql
  def database
  def username = 'root'
  def password = 'password'
  
  @TaskAction
  def runQuery() {
    def cmd
    if(database) {
      cmd = "mysql -u ${username} -p${password} -h ${hostname} -P ${port} ${database} -e "
    }
    else {
      cmd = "mysql -u ${username} -p${password} -h ${hostname} -P ${port} -e "
    }
    project.exec {
      commandLine = cmd.split().toList() + sql
    }
  }
}
</source>
Пользовательская задача <code>MySqlTask</code> наследуется от класса <code>DefaultTask</code>. Все пользовательские задачи должны наследоваться от класса <code>DefaultTask</code>, либо производного от него класса. (Пользовательская задача может наследоваться от любого другого типа задачи, отличного от <code>DefaultTask</code>. См. выше параграф <a href="#TaskTypes">Типы задач</a>, где описаны наиболее важные встроенные типы задач.) В терминах Groovy, в задаче объявлены свойства (такие как <code>hostname</code>, <code>database</code>, <code>sql</code> и т.д.). Далее объявлен метод <code>runQuery()</code>, который помечен аннотацией <code>@TaskAction</code>. <code>runQuery()</code> запустится когда при выполнении задачи.

Фактические задачи билда, определённые в начале билд-файла объявлены как задачи типа <code>MySqlTask</code>. Таким образом они автоматически наследуют свойства и операцию базового класса задач. Для большинства свойств определены значения по умолчанию (однако для таких свойств как <code>username</code> и <code>password</code> значения, конечно же, специфичны для билда), потому остаётся лишь небольшая часть того, что нужно сконфигурировать, прежде чем выполненить каждую из задач. Задачи <code>createDatabase</code> и <code>createUser</code> конфигурируют всего лишь один SQL-запрос и предполагают в дальнейшем использование значений по умолчанию.

Задача <code>createTable</code> переопределяет свойства <code>username</code>, <code>password</code> и <code>database</code>. Таким образом, зависимости задачи создают новую базу данных и пользователя, отличные от административных настроек по умолчанию. Паттерн, который при необходимости переопределяет настройки конфигурации по умолчанию, широко применяется В Gradle.

<h4>Определение пользовательского типа задачи в дереве исходников</h4>
Если пользовательская задача очень велика, её код может существенно усложнять билд-файл. Как было показано в примере выше, задача может состоять из нескольких строк простого кода. Однако на определённом этапе задача может развиться в свою собственную иерархию классов c зависимостями от внешнего API и необходимостью применить автоматизированное тестирование. Билд является кодом, а сложный код билда нужно рассматривать как полноправного обитателя мира разработки кода. Такая задача в Gradle решается просто.

Когда логика пользовательской задачи перерастает разумные пределы билд-файла, мы можем её перенести в директорию <code>buildSrc</code>, которая находится в корне проекта. Директория эта автоматически компилируется и добавляется в classpath билда. Мы изменим предыдущий пример, в котором будем использовать <code>buildSrc</code>:

<h6>Пример 37. Билд-файл использующий пользовательскую задачу, определённый <a href="https://github.com/gradleware/oreilly-gradle-book-examples/tree/master/tasks-custom-task-buildsrc">во внешнем файле</a></h6>
<source lang="javascript">
task createDatabase(type: MySqlTask) {
  sql = 'CREATE DATABASE IF NOT EXISTS example'
}

task createUser(type: MySqlTask, dependsOn: createDatabase) {
  sql = "GRANT ALL PRIVILEGES ON example.* TO exampleuser@localhost IDENTIFIED BY 'passw0rd'"
}

task createTable(type: MySqlTask, dependsOn: createUser) {
  username = 'exampleuser'
  password = 'passw0rd'
  database = 'example'
  sql = 'CREATE TABLE IF NOT EXISTS users (id BIGINT PRIMARY KEY, username VARCHAR(100))'
}
</source>
<h6>Пример 38. Определение пользовательской задачи в директории <code>buildSrc</code></h6>
<source lang="javascript">
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

class MySqlTask extends DefaultTask {
  def hostname = 'localhost'
  def port = 3306
  def sql
  def database
  def username = 'root'
  def password = 'password'
  
  @TaskAction
  def runQuery() {
    def cmd
    if(database) {
      cmd = "mysql -u ${username} -p${password} -h ${hostname} -P ${port} ${database} -e "
    }
    else {
      cmd = "mysql -u ${username} -p${password} -h ${hostname} -P ${port} -e "
    }
    project.exec {
      commandLine = cmd.split().toList() + sql
    }
  }
}
</source>
Заметим, что определение задачи в директории <code>buildSrc</code> полностью совпадает с кодом, включённым в скрипт билда в <a href="#CustomTaskExample">позапрошлом примере</a>. Тем не менее, теперь у нас появляется работоспособная платформа, пригодная для совершенствования кода простой задачи, наращивания объектной модели, написания тестов и всего остального, что мы обычно делаем разрабатывая код.

<i>Есть четыре способа, куда вы можете поместить пользовательский билд-код Gradle. Первый - добавить код собственно, в билд-скрипт, в блок операции таска. Второй - создать внешний файл в директории <code>buildSrc</code>, как было только что сделано в последнем примере. Третий способ - импортировать внешний файл с билд-скриптом в наш основной билд-скрипт. Четвёртый - импорт внешнего модуля, написанного на Java или Goovy. Создание модулей в Gradle - отдельная тема, которую мы затрагивать не будем.</i>

<h6>Пример 39. Структура проекта Gradle, использующего пользовательский код, помещённый в директорию  <code>buildSrc</code></h6>
<source lang="dos">
.
├── build.gradle
├── buildSrc
│   └── src
│       └── main
│           └── groovy
│               └── org
│                   └── gradle
│                       └── example
│                           └── task
│                               └── MySqlTask.groovy
</source>

<h3>Откуда берутся задачи</h3>
До настоящего момента мы создавали задачи путём непосредственного написания кода в билд-скриптах Gradle, либо в директории <code>buildSrc</code> в виде кода Groovy. Такой подход хорош для изучения задач, так как даёт подробный обзор всех их особенностей. Всё же, большинство задач, которые вы будете использовать, не будут написаны вами. Они будут импортироваться из внешних модулей.

В простейшем примере сборки консольного приложения <code>HelloWorld</code> на Java, билд-файл выглядит следующим образом:
<source lang="python">
apply plugin: 'java'
</source>
Применив модуль Java, билд-скрипт автоматически наследует набор задач, код которых вам не виден. Вы можете изменять поведение наследованных задач в <a href="#TaskConfiguration">блоках конфигурации</a>, либо используя рассмотренные выше методы <a href="#DoFirst"><code>doFirst()</code></a> и <a href="#DoLast"><code>doLast()</code></a>, для которых вам придётся писать код. Ключевой стратегией Gradle являются широкие возможности для расширения при малой сложности. Gradle предлагает вам большой набор функциональности посредством задач, подробности реализации которых вам не нужно знать, которые вы запускаете используя Gradle DSL (DSL - Domain Specific Language), а не множество запутанных инструкций кода Groovy.

Кроме того, в Gradle есть несколько встроенных задач, таких как <code>tasks</code> и <code>properties</code>. Такие задачи не импортируются из модулей или вашего кода. Они являются стандартом Gradle DSL.

<h3>Заключение</h3>
В даной главе мы достаточно подробно рассмотрели задачи. Мы разобрались как их можно конфигурировать, создавать в файле скрипта, и получили представление о том, как Gradle разделяет действия для конфигурирования и выполнения между двумя фазами жизненного цикла. Увидели, что задачи являются полноценными объектами Groovy с богатым API. Рассмотрели API задач в достаточном объёме чтобы вы начали воспринимать их как сущности, которые можно менять программно. Мы также рассмотрели некоторые стандартные типы задач, которые даже без дополнительных настроек предоставляют вполне работающую функциональность.

Наконец, мы разобрались как можно создавать ваши собственные задачи программным путём. Для большинства пользователей стандартных возможностей модулей и встроенных задач Gradle достаточно, и для создания билдов пользовательский код можно не писать. Однако случаются исключения. Одна из ключевых возможностей Gradle - облегчить вам расширение возможностей билда без создания хаоса в билд-скриптах с большим объёмом трудноподдерживаемого кода Groovy. Данная возможность была продемонстрирована в примерах пользовательских задач, которые мы рассматривали.

В Gradle задачи являются фундаментальными единицами процесса сборки. Про них можно рассказать намного больше, чем может охватить введение. Всё же, имея в арсенале знания из данной главы, вы уже достаточно подготовлены чтобы начать использовать задачи и продолжать дальнейшее их изучение.